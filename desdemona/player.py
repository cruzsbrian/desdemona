import subprocess
import os

import socketio
import argparse
from desdemona import messages, othello, games


sio = socketio.Client()

match_code = None
color = None

botProcess = None

use_cs2 = False


@sio.event
def connect():
    """
    Connection established with server; register this player in its game.
    """
    print(f"SID: {sio.get_sid()}")
    sio.emit(
        "register",
        messages.RegisterMessage(match_code, color).to_json(),
    )


@sio.event
def game_update(msg_json):
    """
    Read the game update from the server, get the next move through stdin, then
    send it to the server.
    """

    try:
        msg = messages.GameMessage.from_json(msg_json)
    except:
        print("Could not decode message from server")
        return

    if (msg.status == games.Status.PLAYING):
        if msg.ms_remaining[color.value]:
            time_left = str(int(msg.ms_remaining[color.value] * 1000))
        else:
            time_left = "-1"

        # send move to bot
        if msg.last_move:
            if use_cs2:
                botProcess.stdin.write(f"{msg.last_move.col} {msg.last_move.row} {time_left}\n")
            else:
                botProcess.stdin.write(f"{msg.last_move.row} {msg.last_move.col} {time_left}\n")
        else:
            botProcess.stdin.write(f"-1 -1 {time_left}\n")

        botProcess.stdin.flush()

        move_str = botProcess.stdout.readline().strip()
        print(move_str)

        if move_str == "pass":
            move = None
        else:
            try:
                if use_cs2:
                    col, row = [int(x) for x in move_str.split()]
                else:
                    row, col = [int(x) for x in move_str.split()]
                move = othello.Move(color, row, col)
            except:
                print("Invalid move")
                sio.disconnect()

        sio.emit("make_move", messages.MoveMessage(move).to_json())

    else:
        print(f"Game over: {msg.status.value}")
        if msg.status == games.Status.ERROR:
            print(msg.error)

        sio.disconnect()


def run():
    parser = argparse.ArgumentParser()
    parser.add_argument("--cs2", action="store_true",
                        help="Use the CS2 protocol for communication with the bot")
    parser.add_argument("match_code", type=str,
                        help="Match code generated by Desdemona server")
    parser.add_argument("color", type=othello.Color,
                        help="'black' or 'white'")
    parser.add_argument("bot", type=str,
                        help="Path to the bot executable")
    # parser.add_argument('--json', action="store_true",
    #                     help="Provide full GameMessage JSON to the bot")

    args = parser.parse_args()

    global match_code, color
    match_code = args.match_code
    color = args.color
    use_cs2 = args.cs2

    print(f"Starting {args.bot}")

    if use_cs2:
        print("Using the CS2 protocol")

    global botProcess
    botProcess = subprocess.Popen([os.path.join(os.getcwd(), args.bot), color.value],
                                  stdout=subprocess.PIPE,
                                  stdin=subprocess.PIPE,
                                  stderr=None,
                                  text=True)

    print(botProcess.stdout.readline()) # we expect the bot to signal ready

    print(f"Registering for match {match_code} as {color.value}")

    # First see if a local server is running, then try the hosted server
    try:
        sio.connect("http://localhost:5000")
    except:
        sio.connect("http://reversebreakdown.com")

    sio.wait()

    botProcess.kill()
